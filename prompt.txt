You are an expert AI software engineer. I want you to build me a complete Agentic AI system for the hackathon problem:
"Generative AI for Demystifying Legal Documents"
The solution should simplify complex legal documents into clear, accessible guidance. Users should be able to upload documents, get simplified summaries, extract important clauses, understand legal definitions, and ask questions about the content.
The architecture must be multi-agent and modular, with agents communicating via a central controller.

ğŸ”¹ Backend Requirements (Python):
1. Tech Stack
- Python 3.10
- FastAPI for backend API
- LangChain for LLM orchestration
- Pinecone for document retrieval
- Gemini 2.5 flash for LLM tasks
- SQLite for state persistence
- pydantic for schema validation

2. Agentic Architecture
Implement the following agents as modular classes (each agent should have a run(input, state) method):
- Document Retrieval & Analysis Agent:
    Handles document ingestion (PDF/DOCX/TXT).
    Splits documents into chunks.
    Embeds and stores in vector DB (Pinecone).
    Handles semantic search.
- Summarization Agent:
    Provides abstractive summaries of the document.
    Summaries must be hierarchical: (overall, section-wise, clause-level).
- Clauses & Terms Extraction Agent:
    Extracts obligations, rights, penalties, timelines, renewal/termination conditions.
    Returns them as structured JSON.
- Legal Definitions Agent:
    Detects complex legal terms and explains them in simple layman-friendly language.
    Uses dictionary + LLM explanation.
- Q/A Agent:
    Users can ask natural language questions.
    Retrieves relevant chunks from the document and answers with citations.
- Routing, Evaluation & State Management Agent:
    Central controller deciding which agent to route the request to.
    Maintains user session state (uploaded docs, conversation history, extracted summaries).
    Evaluates if userâ€™s query requires summarization, extraction, definition lookup, or Q/A.

3. Backend Endpoints
    POST /upload_document â†’ Upload & process document (store embeddings + metadata).
    POST /summarize â†’ Get summary (overall or section-wise).
    POST /extract_clauses â†’ Extract obligations, penalties, etc.
    POST /define_terms â†’ Get simplified definitions of legal jargon.
    POST /ask â†’ Ask natural language Q/A.
    POST /route â†’ Accepts query and auto-routes to correct agent.
    GET /session_state â†’ Get session state/history.

4. Data Structures
    Store embeddings + metadata in Pinecone.
    Store extracted clauses in JSON format.
    Maintain session state in SQLite/Postgres.


ğŸ”¹ Frontend Requirements (Streamlit)
1. Upload Page
    - Upload legal document (PDF/DOCX).
    - Show metadata (pages, sections).
2. Dashboard
    - Tabs for:
        ğŸ“„ Document Summary
        ğŸ“œ Clauses & Terms Extraction
        ğŸ“– Legal Definitions
        â“ Ask a Question
    - Each tab calls backend endpoints.
3. Conversation Window
    - Persistent chat interface where the Q/A Agent responds.
    - Chat history stored and retrieved from backend session state.
4. UI Features
    - Highlight legal terms with tooltips (hover â†’ simple definition).
    - Expandable accordions for summaries (overall â†’ section â†’ clause).
    - JSON output rendered as formatted tables.

ğŸ”¹ Workflow Example
- User uploads a PDF.
- Retrieval Agent processes â†’ stores embeddings in Pinecone.
- User clicks â€œSummarizeâ€.
- Summarization Agent generates multi-level summary.
- User clicks â€œExtract Clausesâ€.
- Clauses Agent extracts obligations, penalties, etc. in structured JSON.
- User selects the word â€œIndemnificationâ€ and chooses the definition option.
- Definitions Agent gives simple explanation.
- User asks: â€œWhat happens if I terminate early?â€
- Q/A Agent searches embeddings, retrieves termination clause, answers with citations.
- Routing Agent ensures queries go to the right agent seamlessly.

ğŸ”¹ Bonus Features
Add multi-document comparison (e.g., compare two documents).
Add explain like Iâ€™m 5 (ELI5) mode for summaries.
Add compliance checker agent: highlights risky clauses (e.g., arbitration, indemnity).

ğŸ”¹ Deliverables
backend/ â†’ Python FastAPI code with modular agents.
frontend/ â†’ Streamlit app calling backend APIs.
db/ â†’ SQLite/Postgres schema + FAISS/Chroma vector store.
requirements.txt â†’ Dependencies.
README.md â†’ Setup + usage instructions.

âš¡ Now, please generate the entire backend in Python (with the agentic architecture), and the frontend in Streamlit. Ensure the code is modular, production-ready, and hackathon-deployable.